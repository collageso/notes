
2024-09-06 22:30

Tags: [[객체지향 프로그래밍]]


해당 글은 [[의존성 관리 기법]]을 구체적인 원칙이라는 관점에서 정리한 것이다.

- 개방-폐쇄 원칙(Open-Closed Principle, OCP)
	- 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
		- 확장에 대해 열려 있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
		- 수정에 대해 닫혀 있다: 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
	- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
	- 추상화 부분은 수정에 닫혀 있고(공통적인 부분), 추상화를 통해 생략된 부분(구체적인 부분)은 확장의 여지를 남겨야 한다.

- 생성 사용 분리
	- 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 "연결"하는) 시작 단계와 (시작 단계 이후에 이어지는) 실행 단계를 분리해야 한다.
	- 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.
	- FACTORY 추가하기
		- 클라이언트가 생성과 사용의 책임을 함께 지니고 있다면 객체 생성에 특화된 FACTORY 객체를 제작할 수 있다.
	- 순수한 가공물에게 책임 할당하기
		- 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 PURE FABRICATION을 추가하고 이 객체에게 책임을 할당하라
		- 이런 측면에서 객체지향이 실세계의 모방이라는 말은 옳지 않다. 객체지향 애플리케이션의 대부분은 실제 도메인에서 발견할 수 없는 순수한 인공물로 가득 차 있다.
```java
	// Factory는 생성과 관련된 책임만을 가짐
	public class Factory {
		public Movie createAvatarMovie() {
			return new Movie("아바타", Duration.ofMinuites(120), Money.wons(10000), new AmountDiscountPolicy(...))
		}
	}

	// Client는 사용과 관련된 책임만을 가짐
	public class Client {
		private Factory factory;

		public Client(Factory factory) {
			this.factory = factory;
		}

		public Money getAvatarFee() {
			Movie avatar = factory.createAvatarMovie();
			return avatar.getFee();
		}
	}
```

- 의존성 주입
	- 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입(Dependency Injection)이라고 부른다. 즉, 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하는 것이다.
	- 의존성을 해결하는 세 가지 방법
		- 생성자 주입: 객체를 생성하는 시점에 생성자를 통한 의존성 해결
		- setter 주입: 객체 생성 후 setter 메서드를 통한 의존성 해결
		- 메서드 주입: 메서드 실행 시 인자를 이용한 의존성 해결
	- 숨겨진 의존성은 나쁘다 (예: SERVICE LOCATOR 패턴)
		- SERVICE LOCATOR는 의존성을 해결할 객체들을 보관하는 일종의 저장소다. 외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 SERVICE LOCATOR의 경우 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청한다.
		- SERVICE LOCATOR 패턴의 큰 단점은 의존성을 감춘다는 것이다. SERVICE LOCATOR에게 의존성 해결 요청을 보내는 객체의 퍼블릭 인터페이스 어디에도 이 의존성에 대한 정보가 표시돼 있지 않다.
		- 숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어트려 놓기 때문에 코드를 이해하고 테스트 하고 디버깅하기 어렵게 만든다.
```java
	public class ServiceLocator {
		private static ServiceLocator soleInstance = new ServiceLocator()
		private DiscountPolicy discountPolicy;

		public static DiscountPolicy discountPolicy() {
			return soleInstance.discountPolicy;
		}

		public static void provide(DiscountPolicy discountPolicy) {
			soleInstance.discountPolicy = discountPolicy;
		}

		private ServiceLocator() {}
	}
```

- 의존성 역전 원칙 (Dependency Inversioin Principle, DIP)
	- 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다. 따라서 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 된다. (비즈니스의 본질을 담고 있는 상위 수준이 흔들린다)
	- 대부분의 경우 우리가 재사용하려는 대상은 상위 수준의 클래스이기에 상위 수준의 클래스가 하위 수준의 클래스에 의존하면 상위 수준의 클래스를 재사용하기 어려워진다.
	- 의존성 역전 원칙 요약
		- 상위 수준의 모듈(비즈니스 본질)은 하위 수준의 모듈(구체적인 매커니즘)에 의존해서는 안되고, 둘 모두 추상화에 의존해야 한다.
		- 추상화는 구체적인 사항에 의존해서는 안되고 구체적인 사항은 추상화에 의존해야 한다.
	- SEPARATED INTERFACE 패턴
		- 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다. 그리고 함께 재사용될 필요가 없는 그 추상화를 구현하는 클래스들은 별도의 독립적인 패키지에 모아야 한다.
		- 왜냐하면 (여러 곳에서 재사용되는) 클라이언트가 의존하는 추상화가 포함된 패키지 안의 구현 클래스들이 수정되면 패키지 전체가 재배포 되어야 하기 때문이다. (빌드 시간이 가파르게 상승) 
		- 따라서 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다. 전통적인 설계 패러다임은 인터페이스의 소유권을 클라이언트 모듈이 아닌 서버 모듈에 위치시키는 반면 잘 설계된 객체지향 애플리케이션에서는 인터페이스의 소유권을 서버가 아닌 클라이언트에 위치시킨다. (인터페이스가 상위 수준에 속한다)

- 유연성에 대한 조언
	- 유연한 설계는 유연성이 필요할 떄만 옳다.
		- 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함의 미덕을 버리게 될 가능성이 높다.
	- 협력과 책임이 중요하다.
		- 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요하다.
		- 다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 함께 사라진다.
		- 객체를 생성할 책임을 담당할 객체나 객체 생성 매커니즘을 결정하는 시점은 책임 할당의 마지막 단계로 미뤄야만 한다. 중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선이다. 


# References

조영호. (2019). *오브젝트*. p 282-307.