
2024-08-31 18:14

Tags: [[객체지향 프로그래밍]]

- 책임주도 설계란?
	- 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법

- 일반적인 방법론
	- 협력이라는 문맥안에서 메세지가 객체를 결정하도록 해야한다. 즉 객체에게 책임을 할당하는데 필요한 메세지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택하게 하여야 한다.
		-  최소한의 인터페이스를 가질 수 있게 된다. (미니멀리즘)
		- 추상적인 인터페이스를 가질 수 있게 된다. -> 무엇을 하는지는 표현하지만 어떻게 하는지는 노출하지 않는다.
	- 행동이 상태를 결정하도록 해야한다.
		- 객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동이다.
		- 객체의 행동이 상태를 결정하도록 해야 캡슐화를 높일 수 있다.
		- 객체에 필요한 상태가 무엇인지를 먼저 결정하고, 그 후 에 상태에 필요한 행동을 결정하게 되면 객체의 내부 구현이 퍼블릭 인터페이스에 노출되도록 만든다. (데이터 주도 설계)

- 구체적인 방법론
	- 도메인 개념에서 출발하라
		- 높은 수준에서 도메인 개념들과 그 관계를 그려본다.
		- 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.
		- 올바른 도메인 모델이란 존재하지 않는다. -> 필요한 것은 도메인을 그대로 투영한 모델이 아니라 구현에 도움이 되는 모델이다.  -> 유연성이나 재사용성 등과 같이 실제 코드를 구현하면서 얻게 되는 통찰이 역으로 도메인에 대한 개념을 바꾸기도 한다. -> 결론적으로 구현을 가이드할 수 있는 도메인 모델을 선택하라
	- 정보 전문가에게 책임을 할당하라
		- 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임을 생각하고 이 책임을 애플리케이션에 전송된 메시지로 간주하며 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다.
		- 메시지를 전송할 객체는 무엇을 원하는가? (예: 예매하라) -> 메시지를 수신할 적합한 객체는 누구인가? (책임을 수행할 정보를 알고 있는 객체: 정보 전문가)
		- 책임을 수행할 객체가 정보를 '알고' 있다고 해서 그 정보를 '저장'하고 있을 필요는 없다. -> 스스로 처리할 수 없는 작업이 있다면 외부에 도움을 요청한다. -> 외부에 대한 이 요청이 새로운 메시지가 된다.
	- 높은 응집도와 낮은 결합도를 유지할 수 있는 설계를 선택하라
		- 응집도와 결합도는 설계를 진행하면서 책임과 협력의 품질을 검토하는데 사용할 수 있는 중요한 평가 기준이다.
	- 창조자에게 객체 생성 책임을 할당하라
		- 객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?
			- B가 A 객체를 포함하거나 참조한다.
			- B가 A 객체를 기록한다.
			- B가 A 객체를 긴밀하게 사용한다.
			- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (B는 A에 대한 정보 전문가다.)
	- 응집도가 낮은 클래스를 분리해라
		- 아래와 같이 클래스의 응집도가 낮은 경우 클래스를 분리하여야 한다.
			- 클래스가 하나 이상의 이유로 변경되어야 하는 경우 -> 변경의 이유를 기준으로 클래스를 분리
			- 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하는 경우 -> 초기화되는 속성의 그룹을 기준으로 클래스를 분리
			- 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉘는 경우 -> 메서드 그룹을 기준으로 클래스를 분리
		- 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스 분리하여라, 만약 하나의 역할로 다형성을 통해 분리할 수 있는 경우라면 그렇게 하여라
	- 변하는 지점을 캡슐화하여라
		- 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라
		- 예측 가능한 변경으로 인해 클래스들이 불안정해진다면 안정적인 인터페이스 뒤로 변경을 캡슐화하라 (예: 위에서 언급한 추상 클래스나 인터페이스를 만들어 다형성을 통해 분리하는 경우)
	- 상속 대신 합성을 사용하라
		- 코드의 복잡성이 높아지더라도 변경을 쉽게 수용할 수 있도록 유연하게 만들어라.
		- [[상속, 인터페이스, 다형성, 합성]]
	- 


# References

조영호. (2019). *오브젝트*. p 83-86, 133-174.